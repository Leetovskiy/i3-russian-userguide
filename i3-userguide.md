# Руководство пользователя i3

Автор: Майкл Штапельберг, michael@i3wm.org

Перевод: Алексей Литовский, a.leetovskiy@gmail.com

[TOC]

Эта документация содержит всю информацию, которая пригодится для использования и конфигурации оконного менеджера i3. Если по прочтении у Вас остались вопросы, пожалуйста, загляните сначала на https://www.reddit.com/r/i3wm/, затем свяжитесь с нами по IRC (предпочтительно) или опубликуйте свой вопрос в списке почтовой рассылки.

## 1. Стандартные сочетания клавиш

Специально для людей, которые не любят много читать, есть небольшая шпаргалка со стандартными сочетаниями клавиш.

**Сочетания с использованием клавиши $mod (Alt или Super):**

![Сочетания с использованием клавиши $mod (Alt или Super)](https://i3wm.org/docs/keyboard-layer1.png)

**Сочетания с использованием клавиш Shift+$mod:**

![Сочетания с использованием клавиш Shift+$mod](https://i3wm.org/docs/keyboard-layer2.png)

Красные клавиши это модификаторы, которые нужно зажать, голубые – домашний ряд.

Обратите внимание, если запуск i3 сопровождается отсутствием конфигурационного файла, *i3-config-wizard* предложит создать его. Позиции клавиш в этом случае будут совпадать с теми, что изображены на шпаргалке, независимо от раскладки клавиатуры. Если Вы хотите использовать файл конфигурации, где буквенные клавиши совпадают с тем, что вы видите выше, просто отклоните предложение i3-config-wizard и основывайте свою конфигурацию на файле **/etc/i3/config** (прим. переводчика: имеется ввиду, что во втором случае Вы хотите использовать именно буквенные сочетания вместо позиций клавиш).

## 2. Использование i3

В этом руководстве ключевое слово **$mod** ссылается на сконфигурированный модификатор клавиш. По умолчанию это клавиша Alt (**Mod 1**) или Windows (**Mod 4**), которая является популярной альтернативой, предотвращающей конфликты между сочетаниями клавиш, используемыми приложениями.

### 2.1. Запуск терминала и переключение между окнами

Одна из самых базовых операций это запуск терминала. По умолчанию для этого используется сочетание клавиш **$mod+Enter** или Alt+Enter (**Mod1+Enter**) в стандартной конфигурации. По нажатию **$mod+Enter** откроется новый терминал. Он займет все доступное пространство на экране.

![Окно терминала](https://i3wm.org/docs/single_terminal.png)

Теперь, если открыть еще один терминал, i3 поместит его после существующего, разделив экран пополам. В зависимости от Вашего монитора, созданное окно появится рядом с существующим окном (на широких экранах) или под ним.

<img src="https://i3wm.org/docs/two_terminals.png" alt="Два терминала рядом"  />

Чтобы переместить фокус между двумя терминалами можно использовать клавиши направления идентичные редактору **Vi**. Однако, в i3 используется домашний ряд, а в **Vi** эти клавиши смещены влево на одну для совместимости с большинством клавиатурных раскладок. Следовательно, **$mod+j** – направление влево, **$mod+k** – направление вниз, **$mod+l** – вверх, **$mod+;** – вправо. То есть, чтобы переключиться между терминалами нужно использовать **$mod+k** или **$mod+l**. И, конечно же, Вы можете использовать клавиши стрелок. 
Сейчас рабочая область разделена (она содержит два окна терминала) в определенном направлении (горизонтальное по умолчанию). Каждое окно можно разделить еще раз по горизонтали или вертикали прямо как рабочую область, которую мы до этого разделили. Термин "окно" используется для контейнера, который на самом деле содержит окно X11 такие, как терминал или браузер, а "split-контейнер" (разделенный контейнер, далее – сплит-контейнер) для контейнеров, которые состоят из одного или нескольких окон.
Чтобы разделить окно по вертикали нажмите **$mod+v**, прежде чем создать новое окно.

### 2.2. Изменение раскладки контейнера

Сплит-контейнер может иметь одну из следующих раскладок:

|                        splith/splitv                         |                           stacking                           |                            tabbed                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| Окна масштабируются по принципу, чтобы каждое из них забирало равное пространство контейнера. ***splith*** распределяет окна по горизонтали (они находятся рядом друг с другом), а ***splitv*** распределяет их по вертикали (окна находятся друг над другом). | В контейнере отображается только то окно, которое в фокусе. Также, сверху контейнера появляется список окон. | Аналогичен ***stacking***, только список окон отображается горизонтально, как вкладки в браузере. |

Чтобы переключаться между режимами раскладки используйте **$mod+e** для ***splith/splitv*** (переключаются между друг другом), **$mod+s** для ***stacking*** и **$mod+w** для ***tabbed***.

![Режимы раскладки контейнера](https://i3wm.org/docs/modes.png)

### 2.3. Переключение полноэкранного режима окна

Для того, чтобы включить или выключить полноэкранный режим окна используйте **$mod+f**.

Также, в i3, существует глобальный полноэкранный режим, который охватывает все доступные выводы. Переключается командой `fullscreen toggle global`.

### 2.4. Запуск других приложений

Вместо того, чтобы запускать приложения из терминала можно использовать удобный лаунчер ***dmenu***, который по умолчанию открывается сочетанием клавиш **$mod+d**. Просто наберите имя приложения (или его часть), которое хотите запустить. Для работы требуется, чтобы приложение находилось в переменной **$PATH**.

Также, для приложений, которые Вы запускаете часто, можно напрямую задать сочетания клавиш. Подробнее в разделе [Настройка](#configuring).

### 2.5. Закрытие окон

Если приложение не предусматривает механизм завершения (большинство из них предусматривает меню, клавишу escape или горячие клавиши типа **Control-w** для закрытия), можно использовать **$mod+Shift+q**, чтобы "убить" окно. Для приложений, которые поддерживают протокол WM_DELETE, это действие правильно закроет окно (сохранит любые изменения и т.п.). Если же приложение не поддерживает WM_DELETE, то X-сервер просто "убьет" окно, а поведение будет зависеть от определенного приложения.

### 2.6. Использование рабочих пространств

Рабочие пространства (workspaces) это простой способ сгруппировать набор окон. По умолчанию Вы находитесь на первом рабочем пространстве, об этом сообщает индикатор на панели, что находится внизу слева. Чтобы переключиться на другое рабочее пространство нажмите **$mod+num**, где **num** это номер рабочего пространства, которое Вы хотите использовать. Если его не существует, оно будет создано.

Простое применение для этого – переместить браузер на одно рабочее пространство, приложения для общения в сети в другое, а те, с которыми Вы работаете, в третье. Конечно же, Вы не обязаны использовать этот подход.

Если у Вас несколько мониторов, рабочее пространство будет создано для каждого из них во время запуска. Если создать новое рабочее пространство, оно будет привязано к тому экрану, на котором было создано. При переключении к рабочему пространству из другого монитора i3 установит фокус на этот экран.

### 2.7. Перемещение окон между рабочими пространствами

Чтобы переместить окно в другое рабочего пространство просто нажмите **$mod+Shift+num**, где **num** это номер нужного пространства. Также как при переключении, нужное пространство будет создано, если его еще не существует.

### 2.8. Изменение размера

Самый простой способ изменить размер контейнера это использовать мышь: зажмите мышь на границе окна и тяните ее до нужного размера.

Также можно использовать режим привязки клавиш [TODO: добавить ссылку на главу], чтобы менять размеры окна используя клавиатуру. Для примера гляньте на [стандартный конфигурационный файл](https://github.com/i3/i3/blob/next/etc/config.keycodes) предоставленный i3.



### 2.9. Перезапуск i3

Чтобы перезапустить i3 нажмите **$mod+Shift+r**. Пригодится, если произошла какая-то ошибка или нужно обновиться до новой версии оконного менеджера.

### 2.10. Выход из i3

Чтобы выйти из i3 не завершая работу X-сервера можно использовать **$mod+Shift+e**. По умолчанию появится диалоговое окно, которое попросит подтвердить операцию.

### 2.11. Плавающий режим

Плавающий (floating) режим является обратным тайловому. Положение и размеры окна регулируются пользователем вручную, а не автоматическим режимом i3. Использование этого режима нарушает парадигму тайлинга, но может быть полезно для некоторых случаев, когда появляются диалоговые окна (например, "Сохранить как") или окна панели инструментов (GIMP или подобные). Такие окна обычно оставляют подсказку для оконных менеджеров и открываются в плавающем режиме по умолчанию.

Переключить плавающий режим для окна можно с помощью сочетаний **$mod+Shift+Space**. Перетаскивая заголовок окна с помощью мыши можно перемещать окно по рабочему пространству. Чтобы изменить размер нужно зажать и тянуть рамку окна. Также это можно делать с помощью floating_modifier (модификатора плавающих окон) [TODO: добавить ссылку на главу]. Еще один способ это зажать и тянуть ПКМ в заголовке окна.

Об изменении размера плавающих окон с клавиатуры см. режим привязки изменения размера, предусмотренный [конфигурацией i3 по умолчанию](https://github.com/i3/i3/blob/next/etc/config.keycodes).

Плавающие окна всегда находятся поверх тайлинговых.

## 3. Дерево

i3 собирает всю информацию из вывода X11. Рабочие пространства и расположение окон находятся внутри некоего дерева. Корневым узлом является корневое окно X11, за ним следуют выводы X11, затем области стыковки и контейнер содержимого, рабочие области и, наконец, сами окна. 

В предыдущих версиях i3 мы имели несколько списков (выводов, рабочих пространств) и таблицу для каждой рабочей области. Этот подход оказался сложным для использования, понимания и реализации.

### 3.1. Дерево состоит из контейнеров

Кирпичики нашего дерева это контейнеры. Контейнер может содержать окно. Имеется в виду окно X11, которое можно видеть и использовать (например, браузер). Помимо этого, контейнер может содержать другие контейнеры. Простой пример – рабочее пространство: когда i3 запущен с одним монитором, одним рабочим пространством и открыто два терминальных окна, дерево будет выглядеть так:

![Дерево окон](https://i3wm.org/docs/tree-layout2.png)

![Два терминальных окна в одном контейнере](https://i3wm.org/docs/tree-shot4.png)

### 3.2. Ориентация и сплит-контейнеры

При использовании дерева в качестве структуры данных вполне естественно использовать так называемые *сплит-контейнеры* (разделенные контейнеры) для построения раскладки. В i3 каждый *контейнер* имеет свою ориентацию (горизонтальная, вертикальная или неопределенная) и зависит она от раскладки этого контейнера (вертикальная для *splitv* и *stacking*, горизонтальная для *splith* и *tabbed*). В нашем примере с рабочим пространством раскладкой по умолчанию для контейнера является *splith* (большинство мониторов в настоящее время широкоэкранные). Если изменить раскладку на *splitv* (**$mod+v** по умолчанию) и открыть два терминала, то i3 расположит их таким образом:

![Вертикальная ориентация](https://i3wm.org/docs/tree-shot2.png)

С версии 4 i3 имеет интересную возможность – разделять все что угодно: представим, что у нас есть два терминала в рабочем пространстве (в раскладке *splith*, что является горизонтальной ориентацией), фокус окна стоит на правом терминале. Теперь давайте откроем еще один терминал ниже существующего. Если бы мы просто открыли новое окно терминала, то оно отобразилось бы справа благодаря splith-раскладке. Вместо этого нажмите **$mod+v**, чтобы разделить контейнер следуя splitv-раскладке (чтобы открыть горизонтальный сплит-контейнер используйте **$mod+h**). Теперь можно открыть терминал и он появится ниже существующего:

![Вертикальный сплит-контейнер](https://i3wm.org/docs/tree-shot1.png)

![Дерево окон](https://i3wm.org/docs/tree-layout1.png)

Вы, наверное, уже догадались, что нет ограничения в том, насколько глубокой может быть иерархия сплитов (разделений).

### 3.3. Фокусировка на родителе

Давайте оставим вышеуказанный пример. У нас есть терминал слева и два вертикально разделенных терминала справа, фокус на нижнем правом. При открытии нового окна оно откроется ниже текущего.

Как открыть терминальное окно справа от существующего? Для этого нужно переместить фокус на родительский контейнер. В конфигурации по умолчанию для этого используется **$mod+a**, чтобы переместиться на один контейнер выше по дереву (эту операцию можно повторить несколько раз, пока Вы не попадете на контейнер рабочего пространства). В нашем случае вы сфокусируетесь на *вертикальном контейнере*, который находится внутри горизонтально ориентированной рабочей области. Теперь новые окна будут открываться справа от *вертикального сплит-контейнера*:

![shot3](https://i3wm.org/docs/tree-shot3.png)

### 3.4. Неявные контейнеры

В некоторых случаях i3 необходимо неявно создать контейнер для выполнения команды пользователя.

Например: вы запускаете i3 с одним монитором и одной рабочей областью, на которой открываете 3 терминальных окна. Все эти окна напрямую прикрепляются к одному узлу внутри дерева раскладки i3 – узлу рабочей области. По умолчанию узел рабочей области ориентирован *горизонтально*.

Теперь вы перемещаете один из этих терминалов вниз (**$mod+Shift+k** по умолчанию). Ориентация узла рабочей области изменится на *вертикальную*. Окно терминала, которое вы переместили вниз, прикреплено непосредственно к рабочей области и появляется в нижней части экрана. Для размещения двух других окон терминала был создан новый (горизонтальный) контейнер. Вы заметите это при переходе в режим вкладок (например). В результате у вас появится одна вкладка с изображением разделенного контейнера (например, "H[urxvt firefox]"), а другая - терминальное окно, которое вы переместили вниз.

## 4. <span name="configuring">Настройка i3</span>

Здесь начинается настоящее веселье! У каждого имеется свое представление идеального рабочего окружения, поэтому мы не можем сделать разумные настройки по умолчанию для всех пользователей.

Несмотря на то, что i3 не использует язык программирования для конфигурации, он остается достаточно гибким для того, что вы обычно хотите от оконного менеджера.

Например, вы можете настроить: сочетания клавиш для отдельных окон, горячие клавиши для запуска определенных приложений на определенном рабочем пространстве, автоматический запуск приложений, внешний вид i3, установить ваши собственные сочетания клавиш для каких-нибудь полезных вещей.

Чтобы изменить конфигурацию i3 скопируйте файл из `/etc/i3/config` в `~/.i3/config` (или в `~/.config/i3/config`, если вам нравится схема директорий XDG) и отредактируйте его любым текстовым редактором.

При первом запуске (и любом другом, если у вас нет конфигурационного файла) i3 предложит создать конфигурационный файл. В мастере настроек можно выбрать между использованием Alt (**Mod1**) или Windows (**Mod4**) в качестве модификатора. Кроме того, созданный конфигурационный файл будет использовать ключевые символы, основываясь на вашей текущей раскладке клавиатуры. Чтобы запустить мастер настройки используйте команду `i3-config-wizard`. Обратите внимание, что у вас не должно быть файла `~/.i3/config`, иначе мастер настройки просто закроется.

i3, начиная с версии 4.0, использует новый формат конфигурирации. i3 попытается автоматически определить версию формата конфигурационного файла, основываясь на нескольких различных ключевых словах, но если вы хотите убедиться, что ваш конфигурационный файл читается в новом формате, включите следующую строку в ваш конфигурационный файл:

`# i3 config file (v4)`

### 4.1. Комментарии.

Рекомендуется использовать комментарии в конфигурационном файле, чтобы правильно задокументировать ваши настройки для последующего использования. Комментарии начинаются с символа **#** и могут быть использованы только в начале строки:

`# Это строка с комментарием`

### 4.2. Шрифты

i3 поддерживает как основные шрифты X, так и шрифты FreeType (с помощью Pango) для отображения оконных заголовков.

Для генерации описания шрифта X можно использовать *xfontsel(1)*. Чтобы увидеть специальные символы (Unicode), вам нужно использовать шрифт, который поддерживает кодировку ISO-10646.

Описание шрифтов FreeType состоит из семейства шрифтов (font family), стиля (style), толщины (вес, weight), варианта (variant), растяжки (stretch) и размера (size). Шрифты FreeType поддерживают отображение справа налево и чаще всего содержат больше Unicode-символов, нежели основные шрифты X.

Если i3 не может открыть заданный в конфигурации шрифт, то он выведет ошибку в log-файл и будет использовать тот, который работает.

**Синтаксис:**

```
font <описание X-шрифта>
font pango:<список семейств> [<опции стиля>] <размер>
```

**Примеры:**

```
font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1
font pango:DejaVu Sans Mono 10
font pango:DejaVu Sans Mono, Terminus Bold Semi-Condensed 11
font pango:Terminus 11px
```

### 4.3. Клавиатурные бинды

Клавиатурные бинды (привязки клавиш) говорят i3, что нужно запустить команду (см. ниже) при нажатии определенной клавиши. i3 позволяет вам забиндить (привязать) как на конкретный keycode (клавиатурный код), так и на keysym (определенный символ). Вы также можете смешивать эти два подхода, но i3 не защитит вас от случая, когда бинды пересекаются.

* Keysym (key symbol, ключ символа) – описание для конкретного символа, такого как "a" или "b", но также могут быть и менее очевидные описания, например, "underscore" вместо "_". Это то, что вы используете в Xmodmap для переноса ключей. Чтобы получить список текущих ключей и их биндов используйте `xmodmap -pke`. Чтобы интерактивно узнать предназначение клавиши используйте `xev`.
* Keycodes не требует назначения символов (удобно для горячих клавиш от поставщика на некоторых ноутбуках) и их предназначение не изменится когда вы смените раскладку клавиатуры на другую (при использовании `xmodmap`).

Рекомендация от автора документации: если вы часто меняете раскладку клавиатуры, но хотите оставить бинды в том же физическом расположении клавиатуры, используйте keycodes. Если вы не меняете раскладку и хотите иметь чистый и простой конфигурационный файл, то используйте keysyms.

Некоторые утилиты (такие как *import* или *xdotool*) могут не запускаться при нажатии клавиш, потому что клавиатура/курсор все еще удерживаются. Для подобных ситуаций может быть полезен флаг `--release`, который выполнит команду после того, как клавиши будут отпущены.

**Синтаксис:**

```
bindsym [--release] [<Группа>+][<модификаторы>+]<keysym> команда
bindcode [--release] [<Группа>+][<модификаторы>+]<keycode> команда
```

**Примеры:**

```
# Переключение полноэкранного режима окна
bindsym $mod+f fullscreen toggle

# Перезапуск i3
bindsym $mod+Shift+r restart

# Специфичные горячие клавиши для ноутбука
bindcode 214 exec --no-startup-id /home/michael/toggle_beamer.sh

# Симуляция ctrl+v при нажатии $mod+x
bindsym --release $mod+x exec --no-startup-id xdotool key --clearmodifiers ctrl+v

# Сделать скриншот области экрана при нажатии $mod+x
bindsym --release $mod+x exec --no-startup-id import /tmp/latest-screenshot.png
```

**Доступные модификаторы**

От Mod1 до Mod5, Shift, Control – стандартные модификаторы, см. *xmodmap(1)*.

**Group1, Group2, Group3, Group4**

При использовании нескольких раскладок клавиатуры (например `setxkbmap -layout us,ru`) можно указать в какой группе XKB должна быть активна раскладка клавиатуры. По умолчанию бинды клавиш переведены в Group1 и активны во всех группах. Если вы хотите переопределить бинды клавиш в одной из ваших раскладок, установите соответствующую группу. Для обратной совместимости используйте "Mode_switch" в качестве алиаса для Group2.

### 4.4. Бинды для мыши

Бинды для мыши сообщают i3 о том, что нужно выполнить определенную команду, когда нажата заданная кнопка мыши в рамках контейнера, где вы кликнули (см. [command_criteria] TODO: добавить ссылку на раздел). Вы можете настроить бинды для мыши таким же образом, как и для клавиатурных клавиш.

**Синтаксис:**

```
bindsym [--release] [--border] [--whole-window] [--exclude-titlebar] [<модификаторы>+]button<n> command
```

По умолчанию бинды будут работать тогда, когда вы кликаете по заголовку окна. Если установлен флаг `--release`, то команда будет запущена после того, как кнопка мыши будет отпущена.

Если установлен флаг `--whole-window`, бинд выполнится в любой части окна, за исключением границы. Чтобы изменить поведение с границей окна установите флаг `--border`.

Если установлен флаг `--exclude-titlebar`, то строка заголовка не будет учитываться.

**Примеры:**

```
# Ср. кнопка мыши над заголовком "убивает" окно
bindsym --release button2 kill

# Ср. кнопка мыши и модификатор над любой частью окна "убивает" окно
bindsym --whole-window $mod+button2 kill

# Пр. кнопка мыши переключает переключает плавающий режим
bindsym button3 floating toggle
bindsym $mod+button3 floating toggle

# Боковые клавиши перемещают окна
bindsym button9 move left
bindsym button8 move right
```

### 4.5. Режимы привязки

Используя разные режимы привязки вы можете установить несколько наборов биндов. При переходе в другой режим привязки все бинды из текущего режима освобождаются, и только бинды, определенные в новом режиме, будут действительны до тех пор, пока вы остаетесь в нем. Единственный заранее определенный режим привязки это *стандартный* (default). С ним изначально i3 начинает работу и ему же принадлежат все бинды, которые не определены в конкретный режим.

Работа с режимами привязки складывается из двух вещей: определение режима привязки и переключение к нему. Для этих задач есть одна конфигурационная директива и одна команда. Оба из них называются *режимами*. Директива используется для определения биндов, принадлежащих конкретному режиму привязки, при этом команда переключится в заданный режим.

Рекомендуется использовать режимы привязки в паре с [переменными]() (TODO: добавить ссылку на раздел), чтобы облегчить поддержку конфигурации. Ниже есть пример того как использовать режим привязки.

Обратите внимание, что рекомендуется назначить бинды для возврата в режим по умолчанию.

Для режимов привязки можно использовать [[pango_markup]()(TODO: указать ссылку)], но необходимо будет включить его, передав флаг `--pango_markup` в определение режима.

**Синтаксис:**

```
# директива конфигурации
mode [--pango_markup] <name>

# команда
mode <name>
```



**Пример:**

```
# Нажмите $mod+o, а затем f, t, Escape или Return, чтобы 
# запустить Firefox,Thunderbid или вернуться в режим по умолчанию.
set $mode_launcher Launch: [f]irefox [t]hunderbird
bindsym $mod+o mode "$mode_launcher"

mode "$mode_launcher" {
    bindsym f exec firefox
    bindsym t exec thunderbird

    bindsym Escape mode "default"
    bindsym Return mode "default"
}
```

### 4.6. Floating-модификатор

Для перемещения плавающих окон можно тянуть их мышью за заголовок или настроить так называемый floating-модификатор, который вы можете затем нажать и щелкнуть в любом месте самого окна, чтобы переместить его. Наиболее распространенной практикой является использование той же клавиши, которой вы используюете для управления окнами (Mod1, например). Затем вы можете нажать кнопку Mod1, щелкнуть по окну левой кнопкой мыши и перетащить его в нужное положение.

Удерживая floating-модификатор, вы можете изменить размер плавающего окна, нажимая на него правой кнопкой мыши и перемещая курсор, удерживая клавишу. Если при этом зажать клавишу Shift, то изменение размера будет пропорциональным.

**Синтаксис:**
```
floating_modifier <модификатор>
```

**Пример:**
```
floating_modifier Mod1
```

### 4.7. Ограничение размеров плавающего окна

Можно указать максимальные и минимальные размеры для плавающих окон. Если из размерностей `floating_maximum_size` указан в значении "-1", то эта размерность будет неограниченной по отношению к ее максимальному значению. Если же размерность неопределена или указана как "0", то i3 будет использовать значение по умолчанию для ограничения максимального размера. Это же относится и к параметру `floating_minimum_size`.

**Синтаксис:**
```
floating_minimum_size <ширина> x <высота>
floating_maximum_size <ширина> x <высота>
```

**Пример:**
```
floating_minimum_size 75 x 50
floating_maximum_size -1 x -1
```

### 4.8. Ориентация для новых рабочих областей

Новые рабочие области по умолчанию получают разумную ориентацию: широкоэкранные мониторы (когда ширина больше высоты) получают горизонтальную ориентацию, поворачивающиеся дисплеи (когда высота больше ширины) – вертикальную.

С помощью директивы `default_orientation` можно изменить это поведение.

**Синтаксис:**
```
default_orientation horizontal|vertical|auto
```

**Пример:**
```
default_orientation vertical
```

### 4.9. Режим раскладки для новых контейнеров

Эта опция определяет в каком режиме будут запускаться новые контейнеры на уровне рабочей области.

**Синтаксис**:
```
workspace_layout default|stacking|tabbed
```

**Пример**:
```
workspace_layout tabbed
```

### 4.10. Выравнивание заголовков окон

Эта опция определяет выравнивание текста в заголовке окна. По умолчанию установлен *left*.

**Синтаксис:**
```
title_align left|center|right
```

### 4.11. Стилизация границы для новых окон

Эта опция определяет стиль для границ новых окон. Значение по умолчанию – *normal*. Обратите внимание, `default_floating_border` применяется только к окнам, которые изначально запущены в режиме *floating* (например, диалоговые окна) и не применяется к тем, которые стали плавающими позже.

Установка стиля границы в режим *pixel* исключает строки заголовков. Стиль *normal* позволяет регулировать ширину границы, сохраняя при этом строку заголовка.

**Синтаксис:**
```
default_border normal|none|pixel
default_border normal|pixel <px>
default_floating_border normal|none|pixel
default_floating_border normal|pixel <px>
```

Обратите внимание, что *new_window* и *new_float* устарели в пользу вышеуказанных опций и будут удалены в будущем. Мы настоятельно рекомендуем использовать новые опции вместо них.

**Пример:**
```
default_border pixel
```

Опции "normal" и "pixel" поддерживают ширину границ в пикселях, хотя это не обязательно указывать.

**Пример:**
```
# Тоже самое, что default_border none
default_border pixel 0

# Граница в 3 пикселя шириной
default_border pixel 3
```

### 4.13. Произвольные команды для конкретных окон (for_window)

Используя директиву `for_window` можно позволить i3 выполнить любую команду при столкновении с определенным окном. Например, это можно использовать, чтобы установить окна в плавающий режим или изменить стиль его границ.

**Синтаксис:**

```
for_window <условие> <команда>
```

**Пример:**
```
# включить плавающий режим для всех окон XTerm
for_window [class="XTerm"] floating enable

# для всех окон urxvt использовать границы в 1 пиксель 
for_window [class="urxvt"] border pixel 1

# Не совсем полезный, но забавный пример:
# сделать окно плавающим, когда каталог меняется на ~/work
for_window [title="x200: ~/work"] floating enable
```

~~Действующие критерии (условия) и команды см. в разделе command_criteria (TODO: добавить ссылку на раздел 6).~~ Выполняться могут только команды, а не директивы конфигурации, ~~см. раздел list_of_commands (TODO: добавить ссылку).~~

### <span name="no_focus">4.14. Отключить фокусировку на новом окне</span>

Когда появляется новое окно, оно тут же попадет в фокус. Директива `no_focus` позволяет изменить это поведение и должно быть использовано в комбинации с command_criteria ~~(TODO: добавить ссылку).~~

Обратите внимание, что это работает не во всех случаях, например, при передаче данных в запущенное приложение, потому что оно требует фокус. Чтобы настроить поведение для таких случаев, обратитесь к разделу [Фокус при активации окна](#focus_on_window_activation).

`no_focus` проигнориуется и в том случае, если открыто первое окно в рабочем пространстве. Это позволяет повысить удобство использования в сочетании с `workspace_layout`.

**Синтаксис:**
```
no_focus <условие>
```

**Пример:**
```
no_focus [window_role="pop-up"]
```

### <span name="part__variables">4.15. Переменные</span>

Как вы узнали в разделе о клавиатурных привязках, вам придется настроить множество биндов, включающих в себя клавиши-модификаторы. Если хочется сэкономить время при создании конфигурации и иметь потом возможность поменять используемый модификатор, то вам пригодятся переменные.

**Синтаксис:**

```
set $<имя> <значение>
```

**Пример:**
```
set $m Mod1
bindsym $m+Shift+r restart
```

Переменные заменяются в файле во время парсинга. Переменные разбираются не рекурсивно, поэтому невозможно определить переменную со значением, содержащим другую переменную. Это совершенно не доставляет никаких проблем, менять это поведение не планируется. Если же вы хотите более гибкую конфигурацию, то вы должны создать небольшой скрипт, который генерирует конфигурационный файл и запускается раньше, чем i3 (например, в файле*~/.xsession* ).

Смотрите [xresources]()(TODO: добавить ссылку), чтобы узнать как создавать переменные на основе ресурсов, загруженных из базы данных xresources.

### 4.16. Ресурсы X

[Переменные](#part__variables) также могут быть соданые с помощью значений, настроенных в базе данных ресурсов X. Например, это полезно, чтобы избежать настройки значений в конфигурации i3. Вместо этого, значения можно задать единожды, в базе данных ресурсов X, для достижения легко поддерживаемой, согласованной цветовой темы во многих X-приложениях. 

Указание ресурса приведет к тому, что он будет загружен из БД ресурсов и присвоит его значение указанной переменной. Это делается буквально, поэтому значение должно быть в формате, который использует i3. Также должно быть указано запасное значение на случай, если ресурс не сможет загрузиться из базы данных.

**Синтаксис:**
```
set_from_resource $<имя> <имя_ресурса> <запасное_значение>
```
**Пример:**
```
# Файл ~/.Xresources должен содержать подобную строку:
#     *color0: #121212
# и должен быть загружен должным образом, например, так:
#     xrdb ~/.Xresources
# Это значение подхватывается другими приложениями (например, эмулятором терминала URxvt) и может быть использовано в i3 подобным образом:
set_from_resource $black i3wm.color0 #000000
```

### 4.18. Автозапуск приложений в i3

Используя ключевое слово `exec`, отдельно от объявления бинда, вы можете задать команды, которые выполнятся во время начального запуска i3. Команды `exec` не будут запущены во время перезапуска i3, но если вам это нужно, используйте `exec_always`. Также, все эти команды будут выполняться по порядку.

Смотрите ~~[command_chaining]()(TODO: добавить ссылку на раздел 6)~~ для получения подробной информации об особом значении символов `;` (точка с запятой) и `,` (запятая). Они связывают вместе команды в i3, поэтому необходимо использовать кавычки ~~(как показано в [exec_quoting]()(TODO: добавить ссылку на раздел 6.1))~~, если они используются в вашей команде.

**Синтаксис:**

```
exec [--no-startup-id] <команда>
exec_always [--no-startup-id] <команда>
```

**Примеры:**

```
exec chromium
exec_always ~/my_script.sh

# Запустить эмулятор терминала urxvt, о запуске которого пока неизвестно
exec --no-startup-id urxvt
```

Про флаг `--no-startup-id` рассказывается в ~~[exec]()(TODO: добавить ссылку на раздел 6.1)~~.

### 4.19. Автоматизация перемещения рабочих областей на конкретные экраны

Если вы используете несколько экранов, то может быть удобно разместить каждую рабочую область на отдельном экране. Кроме того, распределение рабочих областей на экраны будет влиять на то, какая область i3 будет использовать для нового экрана при его добавлении или запуске самого i3 (например, по умолчанию i3 использует 1 раб. область для первого экрана, 2 для второго и так далее).

**Синтаксис:**
```
workspace <рабочая_область> output <выход1> [выход2]…
```

*Выход* является именем RandR выхода, который прикреплен к вашему экрану. На ноутбуках могут быть такие имена как VGA1 и LVDS1. Посмотреть доступные выходы можно с помощью команды `xrandr --current`.

Если ваш X-сервер поддерживает RandR 1.5 или выше, i3 будет использовать объекты RandR-монитора вместо объектов вывода. Запустите `xrandr --listmonitors`, чтобы увидеть список. Обычно объекты монитора содержат только один вывод и их имена, объектов и вывода, совпадают. Но если это не так, в конфигурации i3 вы можете указать либо имя монитора, либо имя выхода. Например, внутри Dell UP2414Q используются два сканера, поэтому его выходные имена могут быть "DP1" и "DP2", а имя монитора - "Dell UP2414Q". 

(Обратите внимание, что даже если вы укажете имя выхода, который не охватывает весь монитор, i3 все равно будет использовать всю область содержащего монитора, а не только выходные данные).

Вы можете указать несколько выходов. Будет использоваться первый доступный.

Если вы используете именованные рабочие пространства, они должны быть процитированы:

**Примеры:**

```
workspace 1 output LVDS1
workspace 2 output primary
workspace 5 output VGA1 LVDS1
workspace "2: vim" output VGA1
```

### 4.20. Изменение цвета

Вы можете изменить все цвета, которые i3 использует для отрисовки оформления окон.

**Синтаксис:**

```
<класс_цвета> <граница> <фон> <текст> <индикатор> <граница_ребенка>
```

(пояснение переводчика: "ребенок" – это, следующий за родительским элементом, элемент)

Класс цвета может быть одним из этих:

* `client.focused` – клиент, который в настоящее время находится в фокусе;
* `client.focused_inactive` – клиент, чей контейнер имеет фокус, но сам не сфокусирован в данный момент;
* `client.unfocused` – клиент, чей контейнер не имеет фокуса;
* `client.urgent` – клиент, который отмечен как "срочный";
* `client.placeholder` – цвет фона и текста используется для отрисовки содержимого окна-платформы (при восстановлении раскладок). Рамка и индикатор игнорируются;
* `client.background` – Цвет фона, который будет использоваться для раскраски фона клиентского окна, поверх которого будет отображаться клиент. Только те клиенты, которые не покрывают всю область этого окна, выставляют этот цвет. Обратите внимание, что этот цветовой класс принимает только один цвет.

Цвета приведены в шестнадцатеричном формате HTML (#rrggbb), см. следующий пример:

**Примеры (стандартные цвета):**

```
# класс					рамка	фон		текст	индик.	  рамка реб.
client.focused          #4c7899 #285577 #ffffff #2e9ef4   #285577
client.focused_inactive #333333 #5f676a #ffffff #484e50   #5f676a
client.unfocused        #333333 #222222 #888888 #292d2e   #222222
client.urgent           #2f343a #900000 #ffffff #900000   #900000
client.placeholder      #000000 #0c0c0c #ffffff #000000   #0c0c0c

client.background       #ffffff
```

Обратите внимание, что цвет вокруг окна ребенка – это "child_border", а цвет "border" – это только две тонкие линии вокруг заглавной панели.

Цвет индикатора используется для указания, где будет открыто новое окно. Для горизонтальных сплит-контейнеров будет окрашена в цвет индикатора правая граница, для вертикальных сплит-контейнеров – нижняя. Это относится только к одиночным окнам внутри сплит-контейнера, которые в противном случае неотличимы от одиночных окон за пределами сплит-контейнера.

### 4.21. Межпроцессное взаимодействие

i3 использует сокеты Unix, чтобы предоставить интерфейс IPC. Это позволяет сторонним программам получать информацию из i3, например, о текущем рабочем пространстве (для отображения панели рабочего пространства), а также управлять i3.

По умолчанию IPC сокет включен и будет создан в `$XDG_RUNTIME_DIR/i3/ipc-socket.%p`, если эта директория доступна. Запасным вариантом будет `/tmp/i3-%u.XXXXXX/ipc-socket.%p`. *%u* – это ваше имя пользователя Unix, *%p* – это PID для i3 и *XXXXXX* – это строка со случайными символами из переносного набора символов для наименования файлов (см. mkdtemp(3)).

Вы можете переопределить путь по умолчанию через переменную окружения I3SOCK или указав директиву ipc-socket. Однако это не рекомендуется, так как i3 по умолчанию делает правильные вещи. Если вы решите изменить ее, настоятельно рекомендуется установить ее в таком месте в вашем домашнем каталоге, чтобы ни один другой пользователь не мог создать этот каталог.

**Пример:**

```
ipc-socket ~/.i3/i3-ipc.sock
```

Далее вы можете использовать приложение *i3-msg*, чтобы выполнить любую команду из [списка команд]()(TODO: добавить ссылку).

### 4.22. Следование фокуса за мышью

По умолчанию фокус окна следует за вашей мышью и переключается, когда курсор пересекает границу окон. Однако, если в вашем случае это доставляет неудобства, то вы можете отключить это поведение и контролировать фокус только с помощью клавиатуры. Мышь по прежнему будет работать внутри активных окон (например, чтобы кликнуть на ссылку в браузере).

**Синтаксис**:

```
focus_follows_mouse yes|no
```

**Пример**:

```
focus_follows_mouse no
```

### 4.23. Искажение мыши

По умолчанию при переключении фокуса на окно на другом выходе (например, при фокусировке окна на рабочей области 3 на выходе VGA-1 из рабочей области 2 на LVDS-1), курсор мыши деформируется к центру этого окна.

С помощью опции `mouse_warping` вы можете контролировать когда курсор должен быть деформирован. `none` полностью отключает деформацию, в то время как `output` это стандартное поведение, описанное выше.

**Синтаксис**:

```
mouse_warping output|none
```

**Пример**:

```
mouse_warping none
```

### 4.24. Всплывающие окна в полноэкранном режиме

Когда вы находитесь в полноэкранном режиме некоторые приложения продолжают открывать всплывающие окна (возьмите Xpdf для примера). Это происходит потому, что эти приложения могут не знать о том, что они развернуты в полный экран (они не читают соответствующую подсказку). Есть 3 варианта того, что делать в данной ситуации:

1. Отображать всплывающее окно, если оно принадлежит только полноэкранному приложению. Это поведение по умолчанию и должно подходить для большинства пользователей. 
2. Просто игнорировать всплывающее окно. Это не помешает вам, пока вы в полноэкранном режиме, однако, некоторые приложения могут плохо реагировать на это (заблокироваться, когда вы покинете полноэкранный режим).
3. Выйти из полноэкранного режима.

**Синтаксис**:

```
popup_during_fullscreen smart|ignore|leave_fullscreen
```

**Пример**:

```
popup_during_fullscreen smart
```

### 4.25. Обертка фокуса

Представим, что есть контейнер с несколькими окнами или дочерними контейнерами. Если попробовать переместить фокус по краю контейнера, то фокус перейдет к противоположному окну, при условии, что других контейнеров в этом направлении нет. Это называется оборачиванием фокуса.

Если хотите, то можно отключить данное поведение установкой директивы `focus_wrapping` в значение `no`.

Обертка фокуса не произойдет, если есть другое окно или контейнер в указанном направлении. Фокус просто будет установлен на этом окне. Это поведение по умолчанию, поэтому вы "из коробки" можете перемещаться по всем своим окнам не используя *фокус родителя*.

Если вы хотите, чтобы фокус всегда был обернут и знаете как пользоваться *родительским фокусом* для переключения на разные контейнеры, вы можете установить `focus_wrapping` в значение `force`.

Чтобы ограничить фокус внутри текущего рабочего пространства установите `focus_wrapping` в значение `workspace`. Вам придется использовать *родительский фокус* до тех пор, пока вы не переключитесь на другую рабочую область с помощью команд фокусировки (команда `workspace` будет работать как и прежде).

**Синтаксис:**
```
focus_wrapping yes|no|force|workspace

# Старый синтаксис, эквивалентный "focus_wrapping force"
force_focus_wrapping yes
```

**Примеры:**
```
# Выключить обертывание фокуса
focus_wrapping no

# Принудительное обертывание
focus_wrapping force
```

### 4.26. Принудительное использование Xinerama

Некоторые видео-драйвера X11 (особенно бинарный драйвер nvidia) предоставляют поддержку только для Xinerama вместо RandR, об этом подробно написано [здесь](https://i3wm.org/docs/multi-monitor.html). В этом случае i3 необходимо явно указать использовать уступающий Xinerama API и, следовательно, перестать поддерживать переконфигурацию экранов "на лету" (они считываются только **единожды** при запуске).

Для пользователей, которые не могут изменять `~/.xsession` файл и, соответственно, добавить параметр `--force-xinerama`, конфигурация предоставляет отдельную опцию.

**Синтаксис:**
```
force_xinerama yes|no
```

**Пример:**

```
force_xinerama yes
```

Также обратите внимание, что ваши выводы имеют неочевидные имена при использовании Xinerama, вместо это они отсчитываются с нуля: xinerama-0, xinerama-1 и так далее.

### 4.28. Задержка сброса метки срочности при смене рабочего места

Если приложение на другом рабочем пространстве имеет метку о срочности, то переключение на это раб. пространство может привести к незамедлительному переключению фокуса на это приложение. Это также значит, что внешний вид окна сбросится до того, что описан в *client.focused*. Это может усложнить понимание того, в каком окне изначально произошло событие.

Чтобы избежать этого, вы можете указать задержку перед сбросом срочного состояния, используя директиву `force_display_urgency_hint`. Значение "0" отключает эту функцию.

Задержка по умолчанию – 500 мс.

**Синтаксис:**

```
force_display_urgency_hint <задержка> ms
```
**Пример:**

```
force_display_urgency_hint 500 ms
```

### 4.29. <span name="focus_on_window_activation">Фокус при активации окна</span>

Если окно активировано, например, через `google-chrome www.google.com`, оно может запросить фокус. Так как это может быть нежелательно для пользователя, это поведение можно настроить.

Обратите внимание, что это может и не повлиять на открываемые окна. Чтобы выключить фокусировку новых окон, см. раздел [Отключить фокусировку на новом окне](#no_focus).

**Синтаксис**:

```
focus_on_window_activation smart|urgent|focus|none
```

Описание режимов:

- **smart** – поведение по умолчанию. Если окно запрашивает фокус на активной раб. области, то оно получит его. В другом случае будет установлена метка срочности.

- **urgent** – окно в любом случае будет отмечена как срочное, но фокус не переключится.

- **focus** – окно всегда будет получать фокус и никогда не будет отмечено как срочное.

- **none** – окно не получит ни фокуса, ни метки срочности.

### 4.30. Отображение меток на оформлении окна

Если эта функция активирована, то метки ~~(см. [vim_like_marks]()(TODO: добавить ссылку на раздел 6.14))~~ на окнах будут отображаться. Однако любая метка, начинающаяся с подчеркивания в ее названии ("_"), не будет показана, даже если эта опция активна.

По умолчанию опция имеет значение `yes`.

**Синтаксис**:

```
show_marks yes|no
```

**Пример**:

```
show_marks yes
```

### 4.31. Продолжение строки

Конфигурационные файлы поддерживают продолжение строки, т.е. когда вы заканчиваете строку символом обратного слеша ("\\"), синтаксический анализатор проигнорирует разрыв строки. Эта функция может быть использована для создания более читабельных конфигурационных файлов. Комментированные строки не продолжаются. 

**Примеры**:

```
bindsym Mod1+f \
fullscreen toggle

# запись выше прочитается так же, как и строка ниже
bindsym Mod1+f fullscreen toggle

# эта строка не будет продолжена \
bindsym Mod1+F fullscreen toggle
```